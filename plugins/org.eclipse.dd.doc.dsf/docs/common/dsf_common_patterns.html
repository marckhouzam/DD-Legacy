<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>DSF Common Patterns</title>
</head>
<body>
<h2 style="text-align: center;">DSF Common Patterns<br>
</h2>
<h4>Summary</h4>
<h3>Examples<br>
</h3>
Running example code is and performing included excercises is very
helpful in following this tutorial.&nbsp; In order to run the examples
in this tutorial the following is needed:<br>
<ol>
  <li>Download and install Eclipse development environment, either the <span
 style="font-style: italic;">Eclipse Classic 3.4 </span>or <span
 style="font-style: italic;">Eclipse IDE for C/C++ Developers</span><br>
  </li>
  <li>Install the DSF SDK feature to build against, by performing
either:<br>
  </li>
  <ol style="list-style-type: lower-alpha;">
    <li>Using update manager, install the <span
 style="font-style: italic;">Debugger Services Framework end-user and
extender SDK</span>, found in the <span style="font-style: italic;">Ganymede
Discovery Site</span> under <span style="font-style: italic;">Remote
Access and Device Development</span>.</li>
    <li>Check out <span style="font-style: italic;">org.eclipse.dd.dsf
and org.eclipse.dd.dsf.ui</span> plugins, found in the <span
 style="font-style: italic;">/cvsroot/dsdp</span> repository under <span
 style="font-style: italic;">org.eclipse.dd.dsf/plugins</span>
directory.</li>
  </ol>
  <li>Check out the <span style="font-style: italic;">org.eclipse.dd.examples.dsf</span>
plugin, found <span style="font-style: italic;">/cvsroot/dsdp</span>
under <span style="font-style: italic;">org.eclipse.dd.dsf/plugins</span>
directory.</li>
  <li>Build the examples plugin:</li>
  <ol style="list-style-type: lower-alpha;">
    <li>Execute the build the first time to build and run the
excercises preprocessor.</li>
    <li>Refresh the resources in the plugin (right-click on project in <span
 style="font-style: italic;">Navigator</span> and select <span
 style="font-style: italic;">Refresh</span>), in order to recognize the
sources generated by the preprocessor.</li>
    <li>Build the plugin again to compile the generated sources.</li>
  </ol>
  <li>Launch the examples</li>
  <ol style="list-style-type: lower-alpha;">
    <li>Examples in data org.eclipse.dd.examples.dsf.requestmonitor and
org.eclipse.dd.examples.dsf.dataviewer packages each contain a public
main() function.&nbsp; They can be launched using the Java Application
launch type.</li>
    <li><span style="color: rgb(255, 0, 0);">TODO: Launching timers
example</span></li>
  </ol>
</ol>
<h3>Asynchronous Methods</h3>
One of the central features of DSF is that it relies very heavily on
the use of asynchronous methods.&nbsp; <span
 style="font-style: italic;">Asynchronous methods</span> here mean
simply methods that <span style="font-weight: bold;">use a callback
object to indicate their completion</span>. The use of asynchronous
methods can be very contageous in a system, where if a lower level API
is composed of asynchronous methods, a higher level system which uses
those methods also has to have asynchronous methods in its interface
(or risk blocking its calling thread).<br>
<br>
<span style="font-style: italic; color: rgb(255, 0, 0);">TODO? :
diagram of a layered system with asynchronous APIs</span><br>
<h4>Request Monitor</h4>
There is a standard callback object used in DSF, the request
monitor.&nbsp; A request monitor has the following features:<br>
<ul>
  <li><span style="text-decoration: underline;">Executor</span> - A
argument to the request monitor constructor allows the user to specify
what executor should be used to invoke the callback method.&nbsp; <br>
  </li>
  <li><span style="text-decoration: underline;">Status</span> -
Asynchronous methods that take a callback can always set the status
indicating the success or failure of the call.</li>
  <li><span style="text-decoration: underline;">Callback Methods</span>
- The request monitor declares several protected methods which are
invoked when the callback is invoked: handleCompleted(), handleOK(),
handleError(), etc.&nbsp; The users may override these methods as
needed to perform additional processing upon asynchronous method
completion.</li>
  <li><span style="text-decoration: underline;">Parent Request Monitor</span>
- If the method calling an asynchronous method is itself asynchronous,
it may set its argument request monitor as the parent of the request
monitor it is creating.&nbsp; The parent request monitor will be <br>
automatically invoked when the lower level request monitor is completed.</li>
</ul>
Following is the snippet from a the
"hello world" example of using a
request monitor:<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.requestmonitor.AsyncHelloWorld</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line26"> 26: </a><strong><font color="#4169e1"><a
 name="AsyncHelloWorld"></a>public class AsyncHelloWorld </font></strong>{<br><br><a
 name="line28"> 28: </a><strong><font color="#4169e1">    public static void main(String[] args)</font></strong> {<br><a
 name="line29"> 29: </a>        Executor executor = ImmediateExecutor.getInstance();<br><a
 name="line30"> 30: </a>        RequestMonitor rm = new RequestMonitor(executor, null);<br><a
 name="line31"> 31: </a>        asyncHelloWorld(rm);<br><a name="line32"> 32: </a>    }<br><br><a
 name="line34"> 34: </a>    static void asyncHelloWorld(RequestMonitor rm) {<br><a
 name="line35"> 35: </a>        System.out.println(<font color="#666666">"Hello world"</font>);<br><a
 name="line36"> 36: </a>        rm.done();<br><a name="line37"></a> 37:     <span
 style="font-family: sans-serif;"></span><a name="line37"></a>}</pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p>
</p>
<ul>
  <li><a name="line37">Line 29 creates an "immediate executor".&nbsp;
Unlike more
sophisticated executors, the immediate executor simply invokes the
runnable it receives immediately.&nbsp; It does not use any threads and
it will never throw a RejectedExecutionException.</a></li>
  <a name="line37"> </a>
  <li>Line 30 creates the request monitor.&nbsp; This
program does not
perform any processing after the callback is invoked, so it does not
override RequestMonitor's completion methods.</li>
  <li>Line 36 marks the callback as completed and
implicilty invokes
the callback method.&nbsp; As a contract with the caller, the
asynchronous method has to invoke done() when its finished.&nbsp; As
there is no compiler support for ensuring that the asynchronous method
completes the request monitor,&nbsp; failure to do so results in common
but often suble and difficult to track down bug</li>
</ul>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204);"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td
 style="text-align: left; background-color: rgb(255, 204, 204);"><span
 style="text-decoration: underline;">Excercise 1</span>: A common
problem in DSF is implementing nested asynchronous methods, this
excercise adds a second-level asynchronous method to
AsyncHelloWorld.&nbsp; <br>
      <p style="font-style: italic;">Look
for comments preceeded with "// TODO Excercise 1" in the
org.eclipse.dd.examples.dsf.requestmonitor.AsyncHelloWorld
module.</p>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Data Request Monitor</h4>
The base request monitor is useful for returning
status of the
asynchronous method, but they do not have an option of returning a
value to the caller.&nbsp; DataRequestMonitor can be used for that
purpose. A simple example of using the data request monitor:<br>
<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.requestmonitor.Async2Plus2</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line22"> 22: </a><strong><font color="#4169e1"><a
 name="Async2Plus2"></a>public class Async2Plus2 </font></strong>{<br><a
 name="line23"> 23: </a>    <br><a name="line24"> 24: </a><strong><font
 color="#4169e1">    public static void main(String[] args)</font></strong> {<br><a
 name="line25"> 25: </a>        Executor executor = ImmediateExecutor.getInstance();<br><a
 name="line26"> 26: </a>        DataRequestMonitor&lt;Integer&gt; rm = <br><a
 name="line27"> 27: </a>            new DataRequestMonitor&lt;Integer&gt;(executor, null) {<br><a
 name="line28"> 28: </a>                @Override<br><a name="line29"> 29: </a><strong><font
 color="#4169e1">                protected void handleCompleted()</font></strong> {<br><a
 name="line30"> 30: </a>                    System.out.println(<font
 color="#666666">"2 + 2 = "</font> + getData());<br><a name="line31"> 31: </a>                }<br><a
 name="line32"> 32: </a>            };<br><a name="line33"> 33: </a>        asyncAdd(2, 2, rm);<br><a
 name="line34"> 34: </a>    }<br><br><a name="line36"> 36: </a>    static void asyncAdd(int value1, int value2, DataRequestMonitor&lt;Integer&gt; rm) {<br><a
 name="line37"> 37: </a>        rm.setData(value1 + value2);<br><a
 name="line38"> 38: </a>        rm.done();<br><a name="line39"> 39: </a>    }<br><a
 name="line40"> 40: </a>}<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Lines 26-27 create the data request monitor using a local class
declaraion.&nbsp; Note the type parameter to DataRequestMonitor allows
for compiler checking of the type when calling getData() and setData()
methods.</li>
  <li>Lines 29-31 override the standard callback to print the result of
the calculation to the console.<br>
  </li>
</ul>
<h4>Multi-Request Monitor</h4>
A common problem when using asynchronous is that several asynchronous
methods need to be called in parallel, so the calling method needs to
somehow manage the completion of several request monitors.&nbsp;
CountingRequestMonitor can be used for this purpose.&nbsp; It is
configured such that it's done() method needs to be called a <span
 style="font-style: italic;">count</span> number of times before the
callback method is invoked.&nbsp; <br>
The following snipped from the AsyncQuicksort example shows a simple
example of using the CountingRequestMonitor:<br>
<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.requestmonitor.AsyncQuicksort.asyncQuickSort()</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line42"> 42: </a>    static void asyncQuicksort(final int[] array, final int left, <br><a
 name="line43"> 43: </a>        final int right, final RequestMonitor rm) <br><a
 name="line44"> 44: </a>    {<br><a name="line45"> 45: </a>        <font
 color="#4169e1">if</font> (right &gt; left) {<br><a name="line46"> 46: </a>            int pivot = left;<br><a
 name="line47"></a><a name="line48"> 48: </a>            int newPivot = partition(array, left, right, pivot);<br><a
 name="line49"> 49: </a>            printArray(array, left, right, newPivot);<a
 name="line50"><br><br></a><a name="line51"> 51: </a>            CountingRequestMonitor countingRm = new CountingRequestMonitor(fgExecutor, rm);<br><a
 name="line52"> 52: </a>            asyncQuicksort(array, left, newPivot - 1, countingRm);<br><a
 name="line53"> 53: </a>            asyncQuicksort(array, newPivot + 1, right, countingRm);<br><a
 name="line54"> 54: </a>            countingRm.setDoneCount(2);<br><a
 name="line56"> 55: </a>        } <font color="#4169e1">else</font> {<br><a
 name="line57"> 56: </a>            rm.done();<br><a name="line58"> 57: </a>        }<br><a
 name="line59"> 58: </a>    }<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Line 50 creates the CountingRequestMonitor.&nbsp; Note that the
parent request monitor is set to the request monitor from the
asyncQuicksort() argument.&nbsp; This parent request monitor is
automatically called when the counting request monitor is completed.</li>
  <li>Lines 51 and 52, use the same instance of counting request
monitor when calling the sub-routine.&nbsp; Each sub-routine will call
done() on the counting request monitor.</li>
  <li>Line 53 sets the count to the number of sub-routines called with
the counting request monitor.&nbsp; Note that the done count can be set
after calling the sub-routines, because the counting request monitor
will not be completed until the count is set. <br>
  </li>
  <li>Line 55 Don't forget to complete the request monitor in all
execution paths!</li>
</ul>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204);"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td
 style="text-align: left; background-color: rgb(255, 204, 204);"><span
 style="text-decoration: underline;">Excercise 2</span>: Converting a
synchronous method into an asynchronous one is another common task in
DSF.&nbsp; This excercise converts the AsyncQuicksort.partition()
method into asynchronous AsyncQuicksort.asyncPartition().&nbsp; <br>
      <p><span style="font-style: italic;">Look
for comments preceeded with "// TODO Excercise 2" in the
org.eclipse.dd.examples.dsf.requestmonitor.AsyncQuicksort
module.</span></p>
      </td>
    </tr>
  </tbody>
</table>
<h3>Concurrency</h3>
The simple examples in previous section used asynchronous method
signatures, however no real asynchronous work was performed since all
execution was performed in the main thread.&nbsp; This section examines
a more typical example of a problem that DSF is intended to solve: a
viewer and an asynchronous data generator.<br>
<p>The IDataGenerator interface contains the following two asynchronous
data access methods:<br>
</p>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.dataviewer.IDataGenerator</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line48"></a><a name="line49"> 49: </a> void getCount(DataRequestMonitor&lt;Integer&gt; rm);<br><a
 name="line50"> 50: </a> void getValue(int index, DataRequestMonitor&lt;String&gt; rm); <br><a
 name="line59"></a></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<p>The example is intended to simulate a realistic problem therefore,
it
can be assumed that these methods do not complete the request monitor
immediately, but rather that the requests are completed on a separate
thread and with some delay.&nbsp; There are two implementations of this
service provided:</p>
<ol>
  <li>DataGeneratorWithThread - Uses a java thread directly and various
synchronization mechanisms for data integrity.<br>
  </li>
  <li>DataGeneratorWithExecutor - Uses a DSF executor for both
asynchronous execution and synchronization.</li>
</ol>
There are also two viewers provided which display data from the data
generator:<br>
<ol>
  <li>SyncDataViewer - Table-based viewer which implements a
synchronous IStructuredContentProvider interface.<br>
  </li>
  <li>AsyncDataViewer - Table-based viewer which implements an
asynchronous ILazyContentProvider interface.</li>
</ol>
<h4>Query</h4>
DSF is designed to facilitate use of asynchronous APIs.&nbsp; However,
sometimes there are situations where a synchronous method has to be
implemented to call an asynchronous method.&nbsp; One utility used to
accomplish this is a DSF Query object.&nbsp; The Query object is meant
to be extended by clients in order to override the asynchronous
execute() method. The client code using a query can use the execute()
implementation in order to call other asynchronous methods.&nbsp; The
following snippet
from SyncDataViewer.getElements()&nbsp; shows the use of Query:<br>
<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.</span><span
 style="font-family: monospace; font-weight: bold;">dataviewer.SyncDataViewer.getElements()</span>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line59"> 59: </a>        <font color="#b22222">// Create the query object for reading data count. </font><br><a
 name="line60"> 60: </a>        Query&lt;Integer&gt; countQuery = new Query&lt;Integer&gt;() {<br><a
 name="line61"> 61: </a>            @Override<br><a name="line62"> 62: </a>            protected void execute(DataRequestMonitor&lt;Integer&gt; rm) {<br><a
 name="line63"> 63: </a>                fDataGenerator.getCount(rm);<br><a
 name="line64"> 64: </a>            }<br><a name="line65"> 65: </a>        };<br><a
 name="line66"> 66: </a>        <br><a name="line67"> 67: </a>        <font
 color="#b22222">// Submit the query to be executed.  A query implements a runnable</font><br><a
 name="line68"> 68: </a>        <font color="#b22222">// interface and it has to be executed in order to do its work.</font><br><a
 name="line69"> 69: </a>        ImmediateExecutor.getInstance().execute(countQuery);<br><a
 name="line70"> 70: </a>        int count = 0;<br><a name="line71"> 71: </a>        <br><a
 name="line72"> 72: </a>        <font color="#b22222">// Block until the query completes, which will happen when the request</font><br><a
 name="line73"> 73: </a>        <font color="#b22222">// monitor of the execute() method is marked done.</font><br><a
 name="line74"> 74: </a>        <font color="#4169e1">try</font> {<br><a
 name="line75"> 75: </a>            count = countQuery.get();<br><a
 name="line76"> 76: </a>        } <font color="#4169e1">catch</font> (Exception e) { <br><a
 name="line77"> 77: </a>            <font color="#b22222">// InterruptedException and ExecutionException can be thrown here.</font><br><a
 name="line78"> 78: </a>            <font color="#b22222">// ExecutionException containing a CoreException will be thrown </font><br><a
 name="line79"> 79: </a>            <font color="#b22222">// if an error status is set to the Query's request monitor.</font><br><a
 name="line80"> 80: </a>            <font color="#4169e1">return</font> new Object[0]; <br><a
 name="line81"> 81: </a>        } <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Line 60 creates the query object.&nbsp; <br>
  </li>
  <li>On line 63, inside the execute() method, the asynchronous
getCount() method is called</li>
  <li>Line 69 submits the query to an executor.&nbsp; This is very
important, because a Query object simply implements Runnable, it will
not perform the work in its exectute() method unless it is submitted to
an executor.&nbsp; <br>
  </li>
  <li>Line 75 blocks while calling the
java.util.concurrent.Future.get() method, implemented by Query, until
the request monitor from the execute() method is completed.</li>
</ul>
<table style="text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellpadding="5" cellspacing="30">
  <tbody>
    <tr>
      <td style="text-align: center; vertical-align: middle;"><img
 title="Sequence diagram of Query use in getElements()."
 style="width: 418px; height: 478px;" alt="" src="query_1.png"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><small><span
 style="font-weight: bold;">Image 1: Detailed sequence of calling
IDataGenerator.getCount() in SyncDataViewer.getElements().</span></small><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;">Note: Using the query object
requires a great deal of care because calling
a blocking method can create performance problems and raises
possibility of deadlock. One common deadlock scenario occurs when
the get() method is being called by a thread which is itself required
for completion of the asynchronous methods called by execute().</td>
    </tr>
  </tbody>
</table>
<p> </p>
<h4>Synchronization</h4>
Managing race conditions and deadlocks is one of the most challanging
problems of large multi-threaded systems.&nbsp; DSF uses a
single-threaded executor as the primary mechanism for safe-guarding
access to data.&nbsp; Methods, which need to access data protected by
the DSF executor, have to access this data inside a runnable submitted
to the executor thread.&nbsp; The following is an example of this from
the DataGeneratorWithExecutor:<br>
<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.dataviewer.DataGeneratorWithExecutor.addListener()</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line174">174: </a><strong><font color="#4169e1">    public void addListener(final Listener listener)</font></strong> {<br><a
 name="line175">175: </a>        <font color="#4169e1">try</font> {<br><a
 name="line176">176: </a>            fExecutor.execute( new DsfRunnable() {<br><a
 name="line177">177: </a><strong><font color="#4169e1">                public void run()</font></strong> {<br><a
 name="line178">178: </a>                    fListeners.add(listener);<br><a
 name="line179">179: </a>                }<br><a name="line180">180: </a>            });<br><a
 name="line181">181: </a>        } <font color="#4169e1">catch</font> (RejectedExecutionException e) {}<br><a
 name="line182">182: </a>    }<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Line 174 declares the addListener() method which can be called on
any thread.</li>
  <li>Line 176 submits a local runnable to the DSF executor.</li>
  <li>Line 178 accesses the protected data: fListeners.</li>
</ul>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204);"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> <span style="font-style: italic;">Note:
It is immediately apparent that this synchronization mechanism
adds a lot of overhead and for such a simple example, it is much less
efficient than using a synchronized section or an atomic
variable.&nbsp; It
is less obvious how this mechanism adds value, however this document is
just a tutorial so the discussion of the merits of the design will be
left out.</span><br>
      </td>
    </tr>
  </tbody>
</table>
<table style="text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellpadding="5" cellspacing="30">
  <tbody>
    <tr>
      <td style="text-align: center;"><img
 style="width: 195px; height: 294px;" alt=""
 title="Synchronization using multiple locks."
 src="synchronization_1.png"></td>
      <td style="text-align: center; vertical-align: middle;"><img
 title="Synchronization using a DSF executor."
 style="width: 267px; height: 322px;" alt="" src="synchronization_2.png"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><small><span
 style="font-weight: bold;">Image 2: Synchronization using multiple
locks on data.</span></small><br>
      </td>
      <td style="vertical-align: top;"><small><span
 style="font-weight: bold;">Image 3: Synchronization using a single
DSF executor thread.</span></small><br>
      </td>
    </tr>
  </tbody>
</table>
Comparing other parts of the two data generator implementation shows
that using the synchronization mechanism above is the principal
difference between the two implementations.&nbsp; One notable exception
is the principal processing loop in each data generator.&nbsp; In the
thread-based implementation this loop is implemented in the run method
of the generator's thread:<br>
<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.dataviewer.DataGeneratorWithThread.run()</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line139">139: </a><strong><font color="#4169e1">    public void run()</font></strong> {<br><a
 name="line140">140: </a>        <font color="#4169e1">try</font> {<br><a
 name="line141">141: </a>            <font color="#4169e1">while</font>(true) {<br><a
 name="line142">142: </a>                <font color="#b22222">// Get the next request from the queue.  The time-out </font><br><a
 name="line143">143: </a>                <font color="#b22222">// ensures that that the random changes get processed. </font><br><a
 name="line144">144: </a>                final Request request = fQueue.poll(100, TimeUnit.MILLISECONDS);<br><a
 name="line145">145: </a>                <br><a name="line146">146: </a>                <font
 color="#b22222">// If a request was dequeued, process it.</font><br><a
 name="line147">147: </a>                <font color="#4169e1">if</font> (request != null) {<br><a
 name="line148">148: </a>                    <font color="#b22222">// Simulate a processing delay.</font><br><a
 name="line149">149: </a>                    Thread.sleep(PROCESSING_DELAY);<br><a
 name="line150">150: </a>                    <br><a name="line151">151: </a>                    <font
 color="#4169e1">if</font> (request instanceof CountRequest) {<br><a
 name="line152">152: </a>                        processCountRequest((CountRequest)request);<br><a
 name="line153">153: </a>                    } <font color="#4169e1">else</font> <font
 color="#4169e1">if</font> (request instanceof ItemRequest) {<br><a
 name="line154">154: </a>                        processItemRequest((ItemRequest)request);<br><a
 name="line155">155: </a>                    } <font color="#4169e1">else</font> <font
 color="#4169e1">if</font> (request instanceof ShutdownRequest) {<br><a
 name="line156">156: </a>                        <font color="#b22222">// If shutting down, just break out of the while(true) </font><br><a
 name="line157">157: </a>                        <font color="#b22222">// loop and thread will exit.</font><br><a
 name="line158">158: </a>                        request.fRequestMonitor.done();<br><a
 name="line159">159: </a>                        <font color="#4169e1">break</font>;<br><a
 name="line160">160: </a>                    }<br><a name="line161">161: </a>                }<br><a
 name="line162">162: </a>                <br><a name="line163">163: </a>                <font
 color="#b22222">// Simulate data changes.</font><br><a name="line164">164: </a>                randomChanges();<br><a
 name="line165">165: </a>            }<br><a name="line166">166: </a>        }<br><a
 name="line167">167: </a>        <font color="#4169e1">catch</font> (InterruptedException x) {}<br><a
 name="line168">168: </a>    } <br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Line 141 creates the loop that runs continuously until the break
statement on line 159.</li>
  <li>Line 149 implements the artcificial processing delay that is
executed for each request.</li>
</ul>
<p>In contrast the executor-based generator uses a dedicated method for
servicing the queue, which is called by every method that adds a new
request to the queue:<br>
</p>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.dataviewer.DataGeneratorWithExecutor.serviceQueue()</span>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line197">197: </a><strong><font color="#4169e1">    private void serviceQueue()</font></strong> {<br><a
 name="line198"></a>...<br><a name="line199"></a><a name="line201">201: </a>        <font
 color="#b22222">// If a queue servicing is already scheduled, do nothing.</font><br><a
 name="line202">202: </a>        <font color="#4169e1">if</font> (fServiceQueueInProgress) {<br><a
 name="line203">203: </a>            <font color="#4169e1">return</font>;<br><a
 name="line204">204: </a>        }<br><a name="line205">205: </a>        <br><a
 name="line206">206: </a>        <font color="#4169e1">if</font> (fQueue.size() != 0) {<br><a
 name="line207">207: </a>            <font color="#b22222">// If there are requests to service, remove one from the queue and </font><br><a
 name="line208">208: </a>            <font color="#b22222">// schedule a runnable to process the request after a processing</font><br><a
 name="line209">209: </a>            <font color="#b22222">// delay.</font><br><a
 name="line210">210: </a>            fServiceQueueInProgress = true;<br><a
 name="line211">211: </a>            final Request request = fQueue.remove(0);<br><a
 name="line212">212: </a>            fExecutor.schedule(<br><a
 name="line213">213: </a>                new DsfRunnable() {<br><a
 name="line214">214: </a><strong><font color="#4169e1">                    public void run()</font></strong> {<br><a
 name="line215">215: </a>                        <font color="#4169e1">if</font> (request instanceof CountRequest) {<br><a
 name="line216">216: </a>                            processCountRequest((CountRequest)request);<br><a
 name="line217">217: </a>                        } <font color="#4169e1">else</font> <font
 color="#4169e1">if</font> (request instanceof ItemRequest) {<br><a
 name="line218">218: </a>                            processItemRequest((ItemRequest)request);<br><a
 name="line219">219: </a>                        } <br><a name="line220">220: </a>                        <br><a
 name="line221">221: </a>                        <font color="#b22222">// Reset the processing flag and process next</font><br><a
 name="line222">222: </a>                        <font color="#b22222">// request.</font><br><a
 name="line223">223: </a>                        fServiceQueueInProgress = false;<br><a
 name="line224">224: </a>                        serviceQueue();<br><a
 name="line225">225: </a>                    }<br><a name="line226">226: </a>                }, <br><a
 name="line227">227: </a>                PROCESSING_DELAY, TimeUnit.MILLISECONDS);<br><a
 name="line228">228: </a>        }<br><a name="line229">229: </a>    }<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>On line 202, the fServiceQueueInProgress flag is used to ensure
that the queue servicing runnable is not scheduled too often.</li>
  <li>Line 211 removes the top request from the queue. <br>
  </li>
  <li>Line 212 calls the ExecutorService.schedule() method to run the
queue servicing runnable, with a delay that simulates the request
processing time.</li>
  <li>Line 224, after servicing runnableis finished, calls
serviceQueue() again to process the next item in the queue.</li>
</ul>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;">Note: When using a single-threaded
executor as the synchronization
method very few other synchronization mechanisms need to be used.&nbsp;
For example the DataGeneratorWithExecutor.fQueue member is just a plain
un-synchronized list.&nbsp; This is true even when using background
threads to perform long-running tasks, as long as these background
threads can call a request monitor when finished.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204);"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td
 style="text-align: left; background-color: rgb(255, 204, 204);"><span
 style="text-decoration: underline;">Excercise 3</span>: One benefit of
the single-threaded executor concurrency model is that as long as a
method is guaranteed to run in the executor thread, this method may
access and modify any of the variables protected by this
executor.&nbsp; This excercise demonstrates performing a somewhat more
complicated operation on protected state data.<br>
      <p><span style="font-style: italic;">Look
for comments preceeded with "// TODO Excercise 3" in the
org.eclipse.dd.examples.dsf.dataviewer.DataGeneratorWithExcecutor
module.</span></p>
      </td>
    </tr>
  </tbody>
</table>
<h4>Annotations</h4>
In any multi-threaded system it can become very difficult to determine
what are the rules governing access to the various data objects.&nbsp;
In a DSF system, it is even more important to identify which data
objects can only be accessed using a designated DSF executor.&nbsp;
Since there is no Java language mechanisms for this purpose, DSF
defines a number annotations that can be used for this purpose.&nbsp;
The annotations are hierarchical, so that if a class has a given
annotation in its declaration, its members and fields are assumed to
have the same access restriction unless otherwise specified.<br>
<p>DSF synchronization annotations defined in
org.eclipse.dd.dsf.concurrent<br>
</p>
<ul>
  <li><span style="text-decoration: underline;">ThreadSafe</span> -
Indicates that the given element can be accessed on any thread.&nbsp;
Typically, if this annotation is used, the given member or class uses
syncrhonized or atomic objects to protect its data.</li>
  <li><span style="text-decoration: underline;">Immutable</span> -
Immutable objects cannot be modified after they are created, thus they
are also thread-safe.&nbsp; The easiest way to make an object
immutable, is to declare all its fields final and make sure that its
fields are also immutable.&nbsp; Examples of immutable objects are Java
Strings, primitive object types, etc.</li>
  <li><span style="text-decoration: underline;">ConfinedToDsfExecutor(executor)</span>
- Indicates that the given object can only be accessed using the given
executor.&nbsp; The executor parameter is a string (since that's the
only allowable parameter type to annotations), but it should indicate
the executor, using classe's member and method names.</li>
  <li><span style="text-decoration: underline;">ThreadSafeAndProhibitedFromDsfExecutor(executor)</span>
- Rarely used, it indicates that the given element can be accessed on
any thread except using the given executor.&nbsp; An example of such a
method would be the SyncDataViewer.getElements() method, which should
never be called using the executor belonging to the data provider.<br>
  </li>
</ul>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: The DSF synchronization
annotations are no more than a comment intended to help make the code
more understandable and maintainable.&nbsp; Unfortunately, since there
is no compiler enforcment of their presence, it is easy to forget to
add them.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204);"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td
 style="text-align: left; background-color: rgb(255, 204, 204);">
      <p><span style="text-decoration: underline;">Excercise 4</span>:
This excercise adds the appropriate synchronization annotations to the
methods and fields of DataProviderWithExecutor. <br>
      </p>
      <p><span style="font-style: italic;">Look
for comments preceeded with "// TODO Excercise 4" in the
org.eclipse.dd.examples.dsf.dataviewer.DataGeneratorWithExcecutor
module.</span></p>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204);"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td
 style="text-align: left; background-color: rgb(255, 204, 204);"><span
 style="text-decoration: underline;">Excercise 5</span>: It is all too
easy to get into a deadlock situation.&nbsp; This excercise
purposefully puts the data viewer system into a deadlock.&nbsp; The
deadlock first renders the data viewer unusable, but the main thread
also gets deadlocked when attempting to exit the program.<br>
      <p><span style="font-style: italic;">Look
for comments preceeded with "// TODO Excercise 5" in the
org.eclipse.dd.examples.dsf.dataviewer.SyncDataViewer
module.</span></p>
      </td>
    </tr>
  </tbody>
</table>
<h3><span style="font-weight: bold;">Timers Example</span></h3>
<span style="font-weight: bold;"></span>The <span
 style="font-style: italic;">Timers</span> example, found in the <span
 style="font-style: italic;">org.eclipse.dd.examples.dsf.timers</span>
package, is used as a reference throughout the following
sections.&nbsp; It is useful to get familiar with this example at this
time.<br>
<p>Timer example defines the following two services:<br>
</p>
<ul>
  <li><span style="text-decoration: underline;">TimerService</span> -
This service manages a set of timers where each timer's value is
incremented every second.&nbsp; The timer service contains the
following features:<br>
  </li>
  <ul>
    <li><span style="font-style: italic;">startTimer()</span> method -
Allows user to create a new timer.&nbsp; It returns the Data Model
context for the new timer.<br>
    </li>
    <li><span style="font-style: italic;">killTimer()</span> method -
Allows the user to delete the given timer.&nbsp; It requires a timer
context.<br>
    </li>
    <li><span style="font-style: italic;">getTimers()</span> method -
Returns the array of contexts for existing timers.<br>
    </li>
    <li><span style="font-style: italic;">getTimerValue()</span> method
- Returns the current value for the given timer context.<br>
    </li>
    <li><span style="font-style: italic;">TimerTickEvent</span> event
class - An event that is generated for every timer, every time its
value changes (once per second).&nbsp; The event contains the timer's
context.<br>
    </li>
  </ul>
  <li><span style="text-decoration: underline;">AlarmService</span> -
This service manages a set of triggers and alarms.&nbsp; Triggers can
be created and destroyed independently.&nbsp; Alarms represent a timer
and a trigger combined.&nbsp; The Alarm service has the following
features:</li>
  <ul>
    <li><span style="font-style: italic;">createTrigger()</span> method
- Creates a new trigger with a given value.&nbsp; It returns a context
to the new trigger.<br>
    </li>
    <li><span style="font-style: italic;">deleteTrigger()</span> method
- Deletes the trigger for the given context.<br>
    </li>
    <li><span style="font-style: italic;">setTriggerValue()</span>
method - Sets the value of a trigger to the given value.<br>
    </li>
    <li><span style="font-style: italic;">getAlarm()</span> method -
Gets the alarm for the specified timer and trigger contexts.&nbsp; It
returns an alarm context object.<br>
    </li>
    <li><span style="font-style: italic;">AlarmTriggeredDMEvent</span>
event class - An event that is generated for every timer that trips the
given trigger by surpassing its value.&nbsp; The event contains an
alarm context.<br>
    </li>
  </ul>
</ul>
The Timers example also features a user interface for displaying and
manipulating the data in the example's services.&nbsp; The principal
component of this UI is a view that can be opened by following the
menus: <span style="font-style: italic;">Window-&gt;Show View-&gt;Other</span>,
then selecting <span style="font-style: italic;">DSF
Examples-&gt;Timers</span> View in the selection dialog.&nbsp; This
view contains a tree viewer which displays the timers, triggers, and
alarms in a hierarchy.&nbsp; The alarms are only shown when triggered
and are automatically selected upon a triggered event.<br>
<table style="text-align: left; margin-left: auto; margin-right: auto;"
 border="0" cellpadding="5" cellspacing="30">
  <tbody>
    <tr>
      <td style="text-align: center; vertical-align: middle;"><img
 title="Screen shot of the Timers view."
 style="width: 635px; height: 234px;" alt="" src="timers_1.png"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;"><small><span
 style="font-weight: bold;">Image 4: Screen shot of the Timers view.</span></small><br>
      </td>
    </tr>
  </tbody>
</table>
Other features of the Timers example UI include:<br>
<ul>
  <li><span style="text-decoration: underline;">New Timer action</span>
- Adds a new timer, which immediately shows up in the view.</li>
  <li><span style="text-decoration: underline;">New Trigger action</span>
- Opens a dialog where the user enters the value of the new
trigger.&nbsp; Upon OK, the dialog creates a new trigger that is added
to the view.</li>
  <li><span style="text-decoration: underline;">Remove action</span> -
Removes a timer or a trigger, whichever is currently selected in the
viewer.<br>
  </li>
  <li><span style="text-decoration: underline;">Toggle Layout action</span>
- Switches the hierarchy in the tree to either <span
 style="font-style: italic;">Timers-&gt;Triggers-&gt;Alarm</span> or <span
 style="font-style: italic;">Triggers-&gt;Timers-&gt;Alarm</span></li>
  <li><span style="text-decoration: underline;">Edit Trigger Value cell
editor</span> - changes the value of the selected trigger.<span
 style="font-style: italic;"><br>
    </span></li>
</ul>
<h3>Services</h3>
<h4>OSGi</h4>
DSF builds on top of OSGi services APIs.&nbsp;&nbsp; OSGi offers a rich
API for managing services and it is important to understand some of the
OSGi service API basics in order to use DSF<br>
<ul>
  <li><span style="text-decoration: underline;">Registration</span> -
Services need to register and unregister themselves with OSGi framework</li>
  <ul>
    <li><span style="font-style: italic;">BundleContext.registerService()</span>
- registers a service, it returns a ServiceRegistration object which
should be retained by the caller.</li>
    <li><span style="font-style: italic;">ServiceRegistration.unregister()</span>
- unregisters a service.</li>
  </ul>
  <li><span style="text-decoration: underline;">References</span> -
Clients wishing to use a service, need to obtain a reference to the
service.&nbsp; OSGi features reference counting for services.</li>
  <ul>
    <li>BundleContext.getServiceReference(),
BundleContext.getServiceReferences(),
BundleContext.getAllServiceReferences() - methods for retrieving a
reference to a service using a class name and/or a property filter.</li>
    <li>BundleContext.ungetService() - Releases a service reference and
decrements its use count.</li>
  </ul>
  <li><span style="text-decoration: underline;">Events</span> - Clients
using services should listen to service events.&nbsp; Events are issued
when services are added/removed/modified.</li>
  <ul>
    <li>org.osgi.framework.ServiceListener - interface for a service
listener.&nbsp; Objects implementing this interface can be registered
with the BundleContext</li>
  </ul>
</ul>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: The service APIs all use the
BundleContext and they require the BundleContext to be active.&nbsp;
This means DSF-based debugger integrations initialize after the plugin
is started, but&nbsp; that they also shut down before the plugin is
stopped.&nbsp; The first part is not difficult, but the second part
usually requires that the plugin's BundleActivator.stop() method shuts
down the debugger.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Session</h4>
DSF-based debugger integrations can register many services and there
can be multiple instances of debuggers registering services with the
same interfaces.&nbsp; To help coordinate services in a give debugger
instance and distinguish the services between the instances of
debuggers, DSF services are organized into sessions.<br>
<p>DSF Session features include:<br>
</p>
<ul>
  <li><span style="text-decoration: underline;">Unique Session ID</span>
- This ID is used to distinguish services from different
sessions.&nbsp; Clients may also obtain a session instance using an ID
through a static method.<br>
  </li>
  <li>Session Lifecycle Events - Clients may register to listen when
sessions are started and ended.<br>
  </li>
  <li><span style="text-decoration: underline;">DSF Executor</span> -
Eash session has a (single-threaded) DSF Executor&nbsp; associated with
it, though multiple sessions could share a single executor.&nbsp; More
about session executor in the next section.</li>
  <li><span style="text-decoration: underline;">Service Events</span> -
The session is used to dispatch service events.&nbsp; More on events in
following sections.</li>
  <li><span style="text-decoration: underline;">Model Adapters</span> -
A session allws an adapter to be registered, which will be returned by
all Data Model contexts in a given session for a given adapter
type.&nbsp; More information about Data Model is described in the Data
Model section.<br>
  </li>
</ul>
<h4>Executor</h4>
All the services registered with the same session share a single DSF
Executor.&nbsp; By convention, all public service interfaces should be
restricted to being called in this executor thread.&nbsp; This point
goes back to the primary synchronization mechanism of DSF.&nbsp;
Following this rule greatly simplifies the task of protecting the
integrity of service state information.<br>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: All service public methods
should be called using the session's DSF executor. </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Tracker</h4>
Using the OSGi APIs for accessing services directly can be very
cumbersome.&nbsp; A client retrieving a service reference is
responsible for retaining the ServiceReference object and for calling
BundleContext.ungetService() to avoid leaking the refernce.&nbsp; Also,
since a service may be un-registered at any time, the clients need to
listen for events indicating when a service is unregistered.&nbsp;
Fortunately there are two utilities which help with this task<br>
<br>
<table style="text-align: left; width: 100%;" border="0"
 cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <th style="vertical-align: top; text-decoration: underline;"><br>
      </th>
      <th style="vertical-align: top;">org.osgi.util.tracker.ServiceTracker<br>
      </th>
      <th style="vertical-align: top;">org.eclipse.dd.dsf.service.DsfServicesTracker<br>
      </th>
    </tr>
    <tr>
      <td style="vertical-align: top; text-decoration: underline;">Services
tracked<br>
      </td>
      <td style="vertical-align: top;">Tracks all services with a given
class name or filter.&nbsp; <br>
      </td>
      <td style="vertical-align: top;">Tracks all services within a
given DSF session.&nbsp; <br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-decoration: underline;">Thread
safety</td>
      <td style="vertical-align: top;">Thread safe</td>
      <td style="vertical-align: top;">Restricted to the session
executor thread.</td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-decoration: underline;">Accessor
methods<br>
      </td>
      <td style="vertical-align: top;">
      <ul style="list-style-type: circle;">
        <li><span style="font-style: italic;">getService()</span> -
return the first service instance matching the class/filter</li>
        <li><span style="font-style: italic;">getServices()</span> -
returns all references matching the specified class/filter.</li>
      </ul>
      <ul style="list-style-type: circle;">
      </ul>
      </td>
      <td style="vertical-align: top;">
      <ul style="list-style-type: circle;">
        <li><span style="font-style: italic;">getService(Class)</span>
- Returns the first service instance matching given class</li>
        <li><span style="font-style: italic;">getService(Class, String)</span>
- Returns the first service instance matching given class and filter.<br>
        </li>
      </ul>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; text-decoration: underline;">Activation/Disposal
methods<br>
      </td>
      <td style="vertical-align: top;">
      <ul style="list-style-type: circle;">
        <li><span style="font-style: italic;">open()</span> - Starts
tracking maching services.</li>
        <li><span style="font-style: italic;">close()</span> - Shuts
down and un-gets all service references.</li>
      </ul>
      </td>
      <td style="vertical-align: top;">
      <ul style="list-style-type: circle;">
        <li><span style="font-style: italic;">&lt;constructor&gt;</span>
- DSF services tracker can be used immediately after being constucted.</li>
        <li><span style="font-style: italic;">dispose() </span>-
Disposes and un-gets all service references held by the tracker.<br>
        </li>
      </ul>
      </td>
    </tr>
  </tbody>
</table>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: All service trackers must be
disposed (or closed).&nbsp; Failing to dispose a tracker results in a
service reference leak.<br>
      </td>
    </tr>
  </tbody>
</table>
<h4>Initialization / Shutdown</h4>
<span style="text-decoration: underline;"></span>Every DSF service must
implement the IDsfService.initialize() and IDsfService.shutdown()
methods.&nbsp; These methods can only be called in the session executor
thread&nbsp; and are asynchronous.&nbsp; As the last step in
initialization, a service should register itself.&nbsp; Likewise as the
first step of shut-down a service should unregister itself.&nbsp; Also
during initialization, each service should call
DsfSession.getAndIncrementServiceStartupCounter(), in order to obtain
the startup number of the service.&nbsp; This number is used in
prioritizing the service events.<br>
<p>Starting up a large number of DSF services requires calling a number
of asynchronous method in a pre-defined sequence.&nbsp; Implementing
this startup code can be cumbersome and DSF provides a quitility for
implementing it: org.eclipse.dd.dsf.concurrent.Sequence.&nbsp; <br>
</p>
<p>Here's
an example of how the Sequence is extended to perform the task of
shutting down the services in the
Timers example:<br>
</p>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.timers.ServicesStartupSequence</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line25"> 25: </a><strong><font color="#4169e1"><a
 name="ServicesShutdownSequence"></a>public class ServicesShutdownSequence extends Sequence </font></strong>{<br><br><a
 name="line27"> 27: </a>    <font color="#b22222">// Session to that the services are running in.</font><br><a
 name="line28"> 28: </a>    final private DsfSession fSession;<br><a
 name="line29"> 29: </a>    <br><a name="line30"> 30: </a>    <font
 color="#b22222">// DSF Services is created as the first step of the sequence.  It </font><br><a
 name="line31"> 31: </a>    <font color="#b22222">// cannot be created by the constructor because it can only be called</font><br><a
 name="line32"> 32: </a>    <font color="#b22222">// in the session thread.</font><br><a
 name="line33"> 33: </a>    DsfServicesTracker fTracker;<br><br><a
 name="line35"> 35: </a><strong><font color="#4169e1">    public ServicesShutdownSequence(DsfSession session)</font></strong> {<br><a
 name="line36"> 36: </a>        super(session.getExecutor());<br><a
 name="line37"> 37: </a>        fSession = session;<br><a name="line38"> 38: </a>    }<br><a
 name="line39"> 39: </a>    <br><a name="line40"> 40: </a>    Step[] fSteps = new Step[] {<br><a
 name="line41"> 41: </a>        new Step() { <br><a name="line42"> 42: </a>            @Override<br><a
 name="line43"> 43: </a><strong><font color="#4169e1">            public void execute(RequestMonitor requestMonitor)</font></strong> {<br><a
 name="line44"> 44: </a>                fTracker = new DsfServicesTracker(DsfExamplesPlugin.getBundleContext(), fSession.getId());<br><a
 name="line45"> 45: </a>                requestMonitor.done();<br><a
 name="line46"> 46: </a>            }<br><a name="line47"> 47: </a>            <br><a
 name="line48"> 48: </a>            @Override<br><a name="line49"> 49: </a><strong><font
 color="#4169e1">            public void rollBack(RequestMonitor requestMonitor)</font></strong> {<br><a
 name="line50"> 50: </a>                <font color="#b22222">// Dispose the tracker in case shutdown sequence is aborted</font><br><a
 name="line51"> 51: </a>                <font color="#b22222">// and is rolled back.</font><br><a
 name="line52"> 52: </a>                fTracker.dispose();<br><a
 name="line53"> 53: </a>                fTracker = null;<br><a
 name="line54"> 54: </a>                requestMonitor.done();<br><a
 name="line55"> 55: </a>            } <br><a name="line56"> 56: </a>        },<br><a
 name="line57"> 57: </a>        new Step() { <br><a name="line58"> 58: </a>            @Override<br><a
 name="line59"> 59: </a><strong><font color="#4169e1">            public void execute(RequestMonitor requestMonitor)</font></strong> {<br><a
 name="line60"> 60: </a>                shutdownService(AlarmService.class, requestMonitor);<br><a
 name="line61"> 61: </a>            }<br><a name="line62"> 62: </a>        },<br><a
 name="line63"> 63: </a>        new Step() { <br><a name="line64"> 64: </a>            @Override<br><a
 name="line65"> 65: </a><strong><font color="#4169e1">            public void execute(RequestMonitor requestMonitor)</font></strong> {<br><a
 name="line66"> 66: </a>                shutdownService(TimerService.class, requestMonitor);<br><a
 name="line67"> 67: </a>            }<br><a name="line68"> 68: </a>        },<br><a
 name="line69"> 69: </a>        new Step() { <br><a name="line70"> 70: </a>            @Override<br><a
 name="line71"> 71: </a><strong><font color="#4169e1">            public void execute(RequestMonitor requestMonitor)</font></strong> {<br><a
 name="line72"> 72: </a>                <font color="#b22222">// Dispose the tracker after the services are shut down.</font><br><a
 name="line73"> 73: </a>                fTracker.dispose();<br><a
 name="line74"> 74: </a>                fTracker = null;<br><a
 name="line75"> 75: </a>                requestMonitor.done();<br><a
 name="line76"> 76: </a>            }<br><a name="line77"> 77: </a>        }<br><a
 name="line78"> 78: </a>    };<br><a name="line79"> 79: </a>    <br><a
 name="line80"> 80: </a>    @Override<br><a name="line81"> 81: </a>    public Step[] getSteps() { <font
 color="#4169e1">return</font> fSteps; }<br><br><a name="line83"> 83: </a>    <font
 color="#b22222">// A convenience method that shuts down given service.  Only service class </font><br><a
 name="line84"> 84: </a>    <font color="#b22222">// is used to identify the service. </font><br><a
 name="line85"> 85: </a>    private &lt;V extends IDsfService&gt; void shutdownService(Class&lt;V&gt; clazz, RequestMonitor requestMonitor) {<br><a
 name="line86"> 86: </a>        IDsfService service = fTracker.getService(clazz);<br><a
 name="line87"> 87: </a>        <font color="#4169e1">if</font> (service != null) {<br><a
 name="line88"> 88: </a>            service.shutdown(requestMonitor);<br><a
 name="line89"> 89: </a>        }<br><a name="line90"> 90: </a>        <font
 color="#4169e1">else</font> {<br><a name="line91"> 91: </a>            requestMonitor.setStatus(new Status(<br><a
 name="line92"> 92: </a>                IStatus.ERROR, DsfExamplesPlugin.PLUGIN_ID, <br><a
 name="line93"> 93: </a>                IDsfService.INTERNAL_ERROR,  <br><a
 name="line94"> 94: </a>                <font color="#666666">"Service '"</font> + clazz.getName() + <font
 color="#666666">"' not found."</font>, null));             <br><a
 name="line95"> 95: </a>            requestMonitor.done();<br><a
 name="line96"> 96: </a>        }<br><a name="line97"> 97: </a>    }<br><a
 name="line99"> 99: </a>}</pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Line 40 initializes an array of Step objects which are invoked by
the Sequence logic.&nbsp; Each Step class is an inner class with access
to <br>
shared data in the ServicesShutdownSequence class.</li>
  <li>Line 81 implements the protected method used by the Sequence
class to access the steps.</li>
  <li>Line 85 encapsulates the repetitive logic of finding and shutting
down a given service.</li>
  <li>Line 73 disposes the DsfServicesTracker used by the sequence.</li>
</ul>
<p>
Below is the code snipped that invokes the ServicesShutdownSequence in
the Timers example:<br>
</p>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.timers.TimersView</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line181">181: </a>            ServicesShutdownSequence shutdownSeq = <br><a
 name="line182">182: </a>                new ServicesShutdownSequence(fSession);<br><a
 name="line183">183: </a>            fSession.getExecutor().execute(shutdownSeq);<br><a
 name="line184">184: </a>            <font color="#4169e1">try</font> {<br><a
 name="line185">185: </a>                shutdownSeq.get();<br><a
 name="line186">186: </a>            } <font color="#4169e1">catch</font> (InterruptedException e) { assert false;<br><a
 name="line187">187: </a>            } <font color="#4169e1">catch</font> (ExecutionException e) { assert false;<br><a
 name="line188">188: </a>            }<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Line 183 submits the sequence to the session executor.&nbsp; <br>
  </li>
  <li>Line 185 calls the Future.get() method of the sequence to block
the calling thread until the sequence completes.</li>
</ul>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: Sequence implements the
java.util.concurrent.Future interface just like the DSF Query
object.&nbsp; However, if the sequence needs to be invoked from the
executor thread, the Future.get() method cannot be used (or a deadlock
would occur).&nbsp; Instead the sequence should be constructed with a
custom request monitor to be invoked at the completion of the sequence.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<h4>Events</h4>
DSF provides a somewhat unusual event mechanism, where event listeners
do not implement any particular listener interface.&nbsp; Instead,
event listeners use the <span style="font-style: italic;">DsfServiceEventHandler</span>
annotation to identify listener methods.&nbsp; DSF finds the annotated
listener methods using reflection.&nbsp; <br>
<p>To generate an event a service must:<br>
</p>
<ol>
  <li>Call <span style="font-style: italic;">DsfSession.dispatchEvent(Object
event, Dictionary&lt;String, String&gt; serviceProperties)</span>
method.&nbsp; The second parameter allows service listeners to filter
events using specific service properties.</li>
</ol>
In order to receive DSF events a client must:<br>
<ol>
  <li>Declare a <span style="font-style: italic;">public</span> event
listener method (method name is not important), which takes an <span
 style="font-style: italic;">event</span> parameter. The type of the
event parameter depends on the event, where the listener will receive
all service events which can be cast to the declared type.&nbsp; A
second optional parameter of type <span style="font-style: italic;">Dictionary&lt;String,
String&gt;</span> allows the event listener to examine the properties
of the service that is sending the event.</li>
  <li>Add itself as a service event listener by calling <span
 style="font-style: italic;">DsfSession.addServiceEventListener()</span>.</li>
</ol>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: DsfSession.dispatchEvent()
calls event listeners in a separate Runnable submitted to the session
executor.&nbsp; This is significant because the event listeners may
call other service methods changing the overall state of the
system.&nbsp; It also implies that the event listeners are always
called in the session executor thread.<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: Service events are
prioritized.&nbsp; Listeners which themselves are services are called
first, in the order that they were initialized.&nbsp; All other
listenres are called after the services.<br>
      </td>
    </tr>
  </tbody>
</table>
<h3>Data Model</h3>
The term <span style="font-style: italic;">Data Model</span> refers to
the natural structure of data that is being retrieved by the DSF
services.&nbsp; One of the great challanges of creating an user
interface for a debugger is that the amount of of data that is
available on the target is much greater than what can be practially
presented to the user.&nbsp; Therefere the debugger services need to
break up the data into chunks with appropriate granularity to achieve
maximum performance and usability.<br>
<h4>IDMContext</h4>
The IDMContext represents a handle to a chunk of data in the Data
Model.&nbsp; This interface is a minimal, yet central feature of the
Data Model API.<br>
<p>What a Data Model context is:<br>
</p>
<ul>
  <li><span style="text-decoration: underline;">It is hierarchical.</span>&nbsp;
Contexts can have other contexts as parents.&nbsp; The hierarchy of
contexts in a given system roughly defines that system's overall Data
Model.&nbsp; More on context hierarchy <br>
    <span style="text-decoration: underline;"></span></li>
  <li><span style="text-decoration: underline;">It extends the </span><span
 style="font-style: italic; text-decoration: underline;">org.eclipse.core.runtime.IAdaptable</span><span
 style="text-decoration: underline;"> interface.</span>&nbsp; This
allows decorators, retargetable actions, etc. to be associated with a
context.</li>
  <li><span style="text-decoration: underline;">It is associated with a
single DSF session.</span>&nbsp; The IDMContext.getSessionID() returns
the session ID of the given context.&nbsp; This allows all clients to
get a handle on the session and the executor needed to access the DSF
services that the context originated from.<br>
  </li>
  <li><span style="text-decoration: underline;">It is thread safe.</span>
This allows context objects to be stored and compared in viewers,
caches, and other clients which may implement their own threading model.<br>
  </li>
  <li><span style="text-decoration: underline;">It is light-weight and
preferably immutable.</span> This allows contexts to be stored by
clients that may persist beyond the life of the services that
originated them.&nbsp; If a context holds references to a lot of data
or it may prevent that data from being garbage collected.</li>
</ul>
What a Data Model context is NOT:<br>
<ul>
  <li><span style="text-decoration: underline;">It is NOT a reference
to a service.</span>&nbsp; Context should not return a reference to a
service directly because clients should use the appropriate OSGi APIs
to obtain references to DSF services.&nbsp; <br>
  </li>
  <li><span style="text-decoration: underline;">It is NOT persistable.</span>&nbsp;
Since a context returns a context ID, it is valid only for the life of
a single DSF session.&nbsp;</li>
</ul>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: An IDMContext object can be
used to retrieve <span style="text-decoration: underline;">any</span>
type of data object from the service.&nbsp; Although there is an
IDMData marker interface defined, its presence it historical and its
use is optional.<br>
      </td>
    </tr>
  </tbody>
</table>
<h4>Context Hierarchy</h4>
One of the most powerful features of the IDMContext interface is that
is is hierarchical.&nbsp; The <span style="font-style: italic;">IDMContext.getParents()</span>
method returns the immediate ancestors of a given context and following
the parents' parents allows clients to traverse the full hierarchy of a
context.&nbsp; <br>
<p>The use of the context hierarchy may be best explained with use of
the Timers example.&nbsp; In the timers example there are three
contexts that are used:<br>
</p>
<ul>
</ul>
<ol>
  <li><span style="text-decoration: underline;">Timer</span> - no
parent contexts<br>
  </li>
  <li><span style="text-decoration: underline;">Trigger</span> - no
parent contexts<br>
  </li>
  <li><span style="text-decoration: underline;">Alarm</span> - requires
both a timer and a trigger as parent contexts</li>
</ol>
<ul>
</ul>
From these, only the third one has any parents (and any hierarchy), the
code snippet below shows how these parents are used in the AlarmService:<br>
<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.timers.AlarmService.isAlarmTriggered()</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;">
      <pre><a name="line209">209: </a><strong><font color="#4169e1">    public boolean isAlarmTriggered(AlarmDMContext alarmCtx)</font></strong> {<br><a
 name="line210">210: </a>        <font color="#b22222">// Extract the timer and trigger contexts.  They should always be part </font><br><a
 name="line211">211: </a>        <font color="#b22222">// of the alarm.</font><br><a
 name="line212">212: </a>        TimerService.TimerDMContext timerCtx = DMContexts.getAncestorOfType(<br><a
 name="line213">213: </a>            alarmCtx, TimerService.TimerDMContext.class);<br><a
 name="line214">214: </a>        TriggerDMContext triggerCtx = DMContexts.getAncestorOfType(<br><a
 name="line215">215: </a>            alarmCtx, TriggerDMContext.class);<br><br><a
 name="line217">217: </a>        assert triggerCtx != null &amp;&amp; timerCtx != null;<br><br><a
 name="line219">219: </a>        <font color="#b22222">// Find the trigger and check whether the timers value has surpassed it. </font><br><a
 name="line220">220: </a>        <font color="#4169e1">if</font> (fTriggers.containsKey(triggerCtx)) {<br><a
 name="line221">221: </a>            int timerValue = getServicesTracker().getService(TimerService.class).<br><a
 name="line222">222: </a>                getTimerValue(timerCtx);<br><a
 name="line223">223: </a>            <br><a name="line224">224: </a>            <font
 color="#4169e1">return</font> timerValue &gt;= fTriggers.get(triggerCtx);<br><a
 name="line225">225: </a>        }<br><a name="line226">226: </a>        <br><a
 name="line227">227: </a>        <font color="#4169e1">return</font> false;<br><a
 name="line228">228: </a>    }<br></pre>
      </td>
    </tr>
  </tbody>
</table>
</div>
<ul>
  <li>Lines 212 and 214 search the context hierarchy of the alarm
context for the timer and trigger contexts.&nbsp; <br>
  </li>
</ul>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: Methods that take a context
as an argument can specify the generic IDMContext as the argument type,
then search this context for a specific context type.&nbsp; The benefit
of this technique is increased flexibility, at the cost of compile-time
type checking, and it is used throughout DSF to avoid dependencies
between service interfaces.<br>
      </td>
    </tr>
  </tbody>
</table>
<h4>DMContexts</h4>
Searching the context hierarchy can be tedious to implement, the
DMContexts utility class contains a few static methods to simplify this
task:<br>
<ul>
  <li><span style="text-decoration: underline;">getAncestorOfType()</span>
- Searches for a context of a specific type in the hierarchy of the
given context.</li>
  <li><span style="text-decoration: underline;">isAncestorOf()</span> -
Checks whether the one of the argument contexts is in the hierarchy of
the other.</li>
  <li><span style="text-decoration: underline;">toList()</span> -
Converts all the contexts in a hierarchy of the give context into a
list.</li>
</ul>
<h3>View Model</h3>
View Model refers to the ideal <span style="font-style: italic;">user-presentable</span>
structure of the data.&nbsp; This is in contrast to the Data Model,
which refers to the <span style="font-style: italic;">natural</span>
data structure, although the two often end up being the same.&nbsp;
Never the less, the needs of the user presentation often change so the
central feature of the View Model is the ability to customize it.<br>
<h4>Flexible Hierarchy</h4>
View Model builds on the <span style="font-style: italic;">flexible
hierarchy</span> API introduced by Debug
Platform team in release 3.2.&nbsp; The flexible hierarchy API has a
few distinguishing features:<br>
<ol>
  <li>There are provider interfaces for every aspect of data
presentation in the viewer (content, label, columns, etc.).&nbsp; <br>
  </li>
  <li>The provider interfaces are retrieved by the viewer <span
 style="text-decoration: underline;">for each element</span> in the
viewer<span style="font-style: italic;"></span>.&nbsp; This allows the
view content to be populated from multiple sources.</li>
  <li>Provider interfaces are asynchronous.&nbsp; <br>
  </li>
</ol>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> Note: Flexible Hierarchy is still
a provisional API in Eclipse Platform 3.4.&nbsp; This virtually
guarantees that DSF will break backward API compatibility in future
releases.&nbsp; However, these APIs have now been widely used by open
source projects such as DD and CDT and also by many commercial Eclipse
integrations, so the API changes are likely to be small and mostly
related to packaging.<br>
      </td>
    </tr>
  </tbody>
</table>
<h4>Adapter Problem<br>
</h4>
The number two feature of flexible hierarchy API is implemented using
the adapter pattern.&nbsp; One down-side of the adapter pattern is that
there can only be one instance of an adapter of a particular type
registered for a given element.&nbsp; For flexible hierarchy providers,
it means that each provider must implement the element presentation
logic for every view that the element appears in, and as a result
adding a new view can force changing a large number of modules.<br>
<p><span style="color: rgb(255, 0, 0);">TODO: add a diagram of the
adapter pattern used by multiple views.<br>
</span><span style="color: rgb(255, 0, 0);"></span></p>
<p>To overcome the adapter pattern limitation, the View Model uses
wrapper objects.&nbsp; The wrapper objects are held by the viewer and
they redirect the requests for different flexible hierarchy providers
to the appropriate modules. <br>
</p>
<p><span style="color: rgb(255, 0, 0);">TODO: add a diagram of the View
Model hierarchy adapter pattern use<br>
</span><span style="color: rgb(255, 0, 0);"></span></p>
<h4>IVMAdapter -&gt; IVMProvider -&gt; IVMNode -&gt; IVMContext</h4>
<br>
<br>
<br>
<br>
<div style="margin-left: 20px;">
<table style="text-align: left; background-color: rgb(238, 238, 238);"
 border="0" cellpadding="5" cellspacing="0">
  <tbody>
    <tr>
      <td colspan="2" rowspan="1" style="vertical-align: top;"><span
 style="font-family: monospace; font-weight: bold;">org.eclipse.dd.examples.dsf.requestmonitor.Async2Plus2</span><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; width: 10px;"><br>
      </td>
      <td style="vertical-align: top;"> <br>
      </td>
    </tr>
  </tbody>
</table>
</div>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204); font-style: italic;"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td style="text-align: left;"> <br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<table
 style="width: 95%; text-align: left; margin-left: auto; margin-right: auto; background-color: rgb(255, 255, 204);"
 border="0" cellpadding="10" cellspacing="0">
  <tbody>
    <tr>
      <td
 style="text-align: left; background-color: rgb(255, 204, 204);"><span
 style="text-decoration: underline;">Excercise abc</span>: xyz </td>
    </tr>
  </tbody>
</table>
<br>
<br>
</body>
</html>
