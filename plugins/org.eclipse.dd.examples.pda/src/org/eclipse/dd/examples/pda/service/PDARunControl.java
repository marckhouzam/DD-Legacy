/*******************************************************************************
 * Copyright (c) 2006, 2008 Wind River Systems and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Wind River Systems - initial API and implementation
 *     Ericsson	AB		  - Modified for handling of multiple threads
 *******************************************************************************/
package org.eclipse.dd.examples.pda.service;

import java.util.Hashtable;

import org.eclipse.dd.dsf.concurrent.DataRequestMonitor;
import org.eclipse.dd.dsf.concurrent.IDsfStatusConstants;
import org.eclipse.dd.dsf.concurrent.Immutable;
import org.eclipse.dd.dsf.concurrent.RequestMonitor;
import org.eclipse.dd.dsf.datamodel.AbstractDMEvent;
import org.eclipse.dd.dsf.datamodel.IDMContext;
import org.eclipse.dd.dsf.datamodel.IDMEvent;
import org.eclipse.dd.dsf.debug.service.IRunControl;
import org.eclipse.dd.dsf.debug.service.command.IEventListener;
import org.eclipse.dd.dsf.service.AbstractDsfService;
import org.eclipse.dd.dsf.service.DsfServiceEventHandler;
import org.eclipse.dd.dsf.service.DsfSession;
import org.eclipse.dd.examples.pda.PDAPlugin;
import org.eclipse.dd.examples.pda.service.commands.PDACommandResult;
import org.eclipse.dd.examples.pda.service.commands.PDAResumeCommand;
import org.eclipse.dd.examples.pda.service.commands.PDAStepCommand;
import org.eclipse.dd.examples.pda.service.commands.PDASuspendCommand;
import org.osgi.framework.BundleContext;


/**
 * Service for monitoring and controlling execution state of the DPA 
 * program.
 * <p>
 * This service depends on the {@link PDACommandControl} service.
 * It must be initialized before this service is initialized.
 * </p>
 */
public class PDARunControl extends AbstractDsfService 
    implements IRunControl, IEventListener
{
    // Implementation note about tracking execution state:
    // This class implements event handlers for the events that are generated by 
    // this service itself.  When the event is dispatched, these handlers will
    // be called first, before any of the clients.  These handlers update the 
    // service's internal state information to make them consistent with the 
    // events being issued.  Doing this in the handlers as opposed to when 
    // the events are generated, guarantees that the state of the service will
    // always be consistent with the events.
    // The purpose of this pattern is to allow clients that listen to service 
    // events and track service state, to be perfectly in sync with the service
    // state.
    
    @Immutable 
    private static class ExecutionDMData implements IExecutionDMData {
        private final StateChangeReason fReason;
        ExecutionDMData(StateChangeReason reason) {
            fReason = reason;
        }
        public StateChangeReason getStateChangeReason() { return fReason; }
    }
    
    @Immutable 
    private static class ResumedEvent extends AbstractDMEvent<IExecutionDMContext> 
        implements IResumedDMEvent
    {
        private final String fPDAEvent;

        ResumedEvent(IExecutionDMContext ctx, String pdaEvent) { 
            super(ctx);
            fPDAEvent = pdaEvent;
        }
        
        public StateChangeReason getReason() {
            if (fPDAEvent.startsWith("resumed breakpoint") || fPDAEvent.startsWith("suspended watch")) {
                return StateChangeReason.BREAKPOINT;
            } else if (fPDAEvent.equals("resumed step") || fPDAEvent.equals("resumed drop")) {
                return StateChangeReason.STEP;
            } else if (fPDAEvent.equals("resumed client")) {
                return StateChangeReason.USER_REQUEST;
            } else {
                return StateChangeReason.UNKNOWN;
            } 
        }
    }
    
    @Immutable
    private static class SuspendedEvent extends AbstractDMEvent<IExecutionDMContext> 
        implements ISuspendedDMEvent
    {
        private final String fPDAEvent;
        
        SuspendedEvent(IExecutionDMContext ctx, String pdaEvent) { 
            super(ctx);
            fPDAEvent = pdaEvent;
        }
        
        public StateChangeReason getReason() {
            if (fPDAEvent.startsWith("suspended breakpoint") || fPDAEvent.startsWith("suspended watch")) {
                return StateChangeReason.BREAKPOINT;
            } else if (fPDAEvent.equals("suspended step") || fPDAEvent.equals("suspended drop")) {
                return StateChangeReason.STEP;
            } else if (fPDAEvent.equals("suspended client")) {
                return StateChangeReason.USER_REQUEST;
            } else {
                return StateChangeReason.UNKNOWN;
            } 
        }
    }

    // Services 
    private PDACommandControl fCommandControl;
    
    // State flags
	private boolean fSuspended = true;
    private boolean fResumePending = false;
	private boolean fStepping = false;
	private StateChangeReason fStateChangeReason;
	
    public PDARunControl(DsfSession session) {
        super(session);
    }
    
    @Override
    protected BundleContext getBundleContext() {
        return PDAPlugin.getBundleContext();
    }
    
    @Override
    public void initialize(final RequestMonitor rm) {
        super.initialize(
            new RequestMonitor(getExecutor(), rm) { 
                @Override
                protected void handleSuccess() {
                    doInitialize(rm);
                }});
    }

    private void doInitialize(final RequestMonitor rm) {
        fCommandControl = getServicesTracker().getService(PDACommandControl.class);

        // Add ourselves as a listener to PDA events, to catch suspended/resumed 
        // events.
        fCommandControl.addEventListener(this);
        
        // Add ourselves as a listener to service events, in order to process
        // our own suspended/resumed events.
        getSession().addServiceEventListener(this, null);
        
        // Register the service with OSGi
        register(new String[]{IRunControl.class.getName(), PDARunControl.class.getName()}, new Hashtable<String,String>());
        
        rm.done();
    }

    @Override
    public void shutdown(final RequestMonitor rm) {
        fCommandControl.removeEventListener(this);
        getSession().removeServiceEventListener(this);
        super.shutdown(rm);
    }
    
    @Deprecated
    @SuppressWarnings("unchecked")
    public void getModelData(IDMContext dmc, DataRequestMonitor<?> rm) {
        // The getModelData() is deprecated and clients are expected to switch
        // to getExecutionData() and other data retrieve methods directly.
        // However the UI cache still uses it for now.
        if (dmc instanceof IExecutionDMContext) {
            getExecutionData((IExecutionDMContext)dmc, (DataRequestMonitor<IExecutionDMData>)rm); 
        } else {
            PDAPlugin.failRequest(rm, INVALID_HANDLE, "Unknown DMC type");
        }
    }
    
    public void eventReceived(Object output) {
        if (!(output instanceof String)) return;
        String event = (String)output;
        
        // Handle PDA debugger suspended/resumed events and issue the 
        // corresponding Data Model events.  Do not update the state
        // information until we start dispatching the service events.
        if (event.startsWith("suspended")) {
            IDMEvent<?> dmEvent = new SuspendedEvent(fCommandControl.getProgramDMContext(), event);
            getSession().dispatchEvent(dmEvent, getProperties());
        } else if (event.startsWith("resumed")) {
            IDMEvent<?> dmEvent = new ResumedEvent(fCommandControl.getProgramDMContext(), event);
            getSession().dispatchEvent(dmEvent, getProperties());
        }
    }
    
    
    @DsfServiceEventHandler 
    public void eventDispatched(ResumedEvent e) {
        // This service should be the first to receive the ResumedEvent, 
        // (before any other listeners are called).  Here, update the
        // service state information based on the the resumed event.
        fSuspended = false;
        fResumePending = false;
        fStateChangeReason = e.getReason();
        fStepping = e.getReason().equals(StateChangeReason.STEP);
    }    


    @DsfServiceEventHandler 
    public void eventDispatched(SuspendedEvent e) {
        // This service should be the first to receive the SuspendedEvent also, 
        // (before any other listeners are called).  Here, update the
        // service state information based on the the suspended event.
        fStateChangeReason = e.getReason();
        fResumePending = false;
        fSuspended = true;
        fStepping = false;
    }
    
    
    public void canResume(IExecutionDMContext context, DataRequestMonitor<Boolean> rm) {
        rm.setData(doCanResume(context));
        rm.done();
    }
    
    private boolean doCanResume(IExecutionDMContext context) {
        return isSuspended(context) && !fResumePending;
    }

    public void canSuspend(IExecutionDMContext context, DataRequestMonitor<Boolean> rm) {
        rm.setData(doCanSuspend(context));
        rm.done();
    }
    
    private boolean doCanSuspend(IExecutionDMContext context) {
        return !isSuspended(context);
    }

	public boolean isSuspended(IExecutionDMContext context) {
		return fSuspended;
	}

	public boolean isStepping(IExecutionDMContext context) {
    	return !isSuspended(context) && fStepping;
    }

	public void resume(IExecutionDMContext context, final RequestMonitor rm) {
		assert context != null;

		if (doCanResume(context)) { 
            fResumePending = true;
            fCommandControl.queueCommand(
            	new PDAResumeCommand(fCommandControl.getProgramDMContext()),
            	new DataRequestMonitor<PDACommandResult>(getExecutor(), rm) { 
                    @Override
                    protected void handleFailure() {
                        // If the resume command failed, we no longer
                        // expect to receive a resumed event.
                        fResumePending = false;
                        super.handleFailure();
                    }
            	}
            );
        }else {
            PDAPlugin.failRequest(rm, INVALID_STATE, "Given context: " + context + ", is already running.");
        }
	}
	
	public void suspend(IExecutionDMContext context, final RequestMonitor rm){
		assert context != null;

		if (doCanSuspend(context)) {
            fCommandControl.queueCommand(
                new PDASuspendCommand(fCommandControl.getProgramDMContext()),
                new DataRequestMonitor<PDACommandResult>(getExecutor(), rm));
            
        } else {
            PDAPlugin.failRequest(rm, IDsfStatusConstants.INVALID_STATE, "Given context: " + context + ", is already suspended."); 
        }
    }
    
    public void canStep(IExecutionDMContext context, StepType stepType, DataRequestMonitor<Boolean> rm) {
        canResume(context, rm);
    }
    
    public void step(IExecutionDMContext context, StepType stepType, final RequestMonitor rm) {
    	assert context != null;
    	
    	if (doCanResume(context)) {
            fResumePending = true;
            fStepping = true;

            fCommandControl.queueCommand(
                new PDAStepCommand(fCommandControl.getProgramDMContext()),
                new DataRequestMonitor<PDACommandResult>(getExecutor(), rm) {
                    @Override
                    protected void handleFailure() {
                        // If the step command failed, we no longer
                        // expect to receive a resumed event.
                        fResumePending = false;
                        fStepping = false;
                    }
                });

    	} else {
            PDAPlugin.failRequest(rm, INVALID_STATE, "Cannot resume context"); 
            return;
        }
    }

    public void getExecutionContexts(final IContainerDMContext containerDmc, final DataRequestMonitor<IExecutionDMContext[]> rm) {
        PDAPlugin.failRequest(rm, NOT_SUPPORTED, "Operation not implemented"); 
    }
    
	public void getExecutionData(IExecutionDMContext dmc, DataRequestMonitor<IExecutionDMData> rm){
        rm.setData( new ExecutionDMData(fStateChangeReason) );
        rm.done();
    }
}
