/*******************************************************************************
 * Copyright (c) 2006 Wind River Systems and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Wind River Systems - initial API and implementation
 *     Ericsson	AB		  - Modified for handling of multiple threads
 *******************************************************************************/
package org.eclipse.dd.examples.pda.service.runcontrol;

import java.util.Hashtable;

import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.dd.dsf.concurrent.DataRequestMonitor;
import org.eclipse.dd.dsf.concurrent.RequestMonitor;
import org.eclipse.dd.dsf.datamodel.IDMContext;
import org.eclipse.dd.dsf.datamodel.IDMEvent;
import org.eclipse.dd.dsf.debug.service.IRunControl;
import org.eclipse.dd.dsf.debug.service.command.CommandCache;
import org.eclipse.dd.dsf.debug.service.command.IEventListener;
import org.eclipse.dd.dsf.service.AbstractDsfService;
import org.eclipse.dd.dsf.service.DsfServiceEventHandler;
import org.eclipse.dd.dsf.service.DsfSession;
import org.eclipse.dd.dsf.service.IDsfService;
import org.eclipse.dd.examples.pda.PDAPlugin;
import org.eclipse.dd.examples.pda.service.command.PDACommandControl;
import org.eclipse.dd.examples.pda.service.command.PDACommandResult;
import org.eclipse.dd.examples.pda.service.command.commands.PDAResumeCommand;
import org.eclipse.dd.examples.pda.service.command.commands.PDAStepCommand;
import org.eclipse.dd.examples.pda.service.command.commands.PDASuspendCommand;
import org.osgi.framework.BundleContext;


/**
 * 
 * <p> 
 * Implementation note:
 * This class implements event handlers for the events that are generated by 
 * this service itself.  When the event is dispatched, these handlers will
 * be called first, before any of the clients.  These handlers update the 
 * service's internal state information to make them consistent with the 
 * events being issued.  Doing this in the handlers as opposed to when 
 * the events are generated, guarantees that the state of the service will
 * always be consistent with the events.
 * The purpose of this pattern is to allow clients that listen to service 
 * events and track service state, to be perfectly in sync with the service
 * state.
 */
public class PDARunControl extends AbstractDsfService 
    implements IRunControl, IEventListener
{
    private PDACommandControl fCommandControl;
	private CommandCache fCommandCache;
    
    // state flags
	private boolean fSuspended = true;
    private boolean fResumePending = false;
	private boolean fStepping = false;
	
	private StateChangeReason fStateChangeReason;
	
    public PDARunControl(DsfSession session) {
        super(session);
    }
    
    @Override
    protected BundleContext getBundleContext() {
        return PDAPlugin.getBundleContext();
    }
    
    @Override
    public void initialize(final RequestMonitor rm) {
        super.initialize(
            new RequestMonitor(getExecutor(), rm) { 
                @Override
                protected void handleOK() {
                    doInitialize(rm);
                }});
    }

    private void doInitialize(final RequestMonitor rm) {
        fCommandControl = getServicesTracker().getService(PDACommandControl.class);
        fCommandCache = new CommandCache(fCommandControl);

        fCommandControl.addEventListener(this);
        getSession().addServiceEventListener(this, null);
        
        register(new String[]{IRunControl.class.getName(), PDARunControl.class.getName()}, new Hashtable<String,String>());
        
        rm.done();
    }

    @Override
    public void shutdown(final RequestMonitor rm) {
        fCommandControl.removeEventListener(this);

        getSession().removeServiceEventListener(this);
        fCommandCache.reset();
        super.shutdown(rm);
    }
    
    @SuppressWarnings("unchecked")
    public void getModelData(IDMContext dmc, DataRequestMonitor<?> rm) {
        if (dmc instanceof IExecutionDMContext) {
            getExecutionData((IExecutionDMContext)dmc, (DataRequestMonitor<IExecutionDMData>)rm); 
        } else {
            rm.setStatus(new Status(IStatus.ERROR, PDAPlugin.PLUGIN_ID, INVALID_HANDLE, "Unknown DMC type", null)); //$NON-NLS-1$
            rm.done();
        }
    }
    
    public void eventReceived(Object output) {
        if (!(output instanceof String)) return;
        String event = (String)output;
        
        if (event.startsWith("suspended")) {
            suspendedEventReceived(event);
        } else if (event.startsWith("resumed")) {
            resumedEventReceived(event);
        }
    }
    
    private void suspendedEventReceived(String event) {
        IDMEvent<?> dmEvent = new SuspendedEvent(fCommandControl.getDMContext(), event);
        getSession().dispatchEvent(dmEvent, getProperties());
    }
    

    @DsfServiceEventHandler 
    private void resumedEventReceived(String event) {
        IDMEvent<?> dmEvent = new ResumedEvent(fCommandControl.getDMContext(), event);
        getSession().dispatchEvent(dmEvent, getProperties());
    }


    @DsfServiceEventHandler 
    public void eventDispatched(ResumedEvent e) {
        fSuspended = false;
        fResumePending = false;
        fStateChangeReason = e.getReason();
        fCommandCache.setTargetAvailable(false);
        if (e.getReason().equals(StateChangeReason.STEP)) {
            fStepping = true;        
        } else {
            fCommandCache.reset();
        }
    }    


    @DsfServiceEventHandler 
    public void eventDispatched(SuspendedEvent e) {
        fCommandCache.setTargetAvailable(true);
        fCommandCache.reset();
        fStateChangeReason = e.getReason();
        fResumePending = false;
        fSuspended = true;
        fStepping = false;
    }
    
    
	public boolean canResume(IExecutionDMContext context) {
        return isSuspended(context) && !fResumePending;
	}

	public boolean canSuspend(IExecutionDMContext context) {
        return !isSuspended(context);
	}

	public boolean isSuspended(IExecutionDMContext context) {
		return fSuspended;
	}

	public boolean isStepping(IExecutionDMContext context) {
    	return !isSuspended(context) && fStepping;
    }

	public void resume(IExecutionDMContext context, final RequestMonitor rm) {
		assert context != null;

		if (canResume(context)) { 
            fResumePending = true;
            // Cygwin GDB will accept commands and execute them after the step
            // which is not what we want, so mark the target as unavailable
            // as soon as we send a resume command.
            fCommandCache.setTargetAvailable(false);
            
            fCommandControl.queueCommand(
            	new PDAResumeCommand(fCommandControl.getDMContext()),
            	new DataRequestMonitor<PDACommandResult>(getExecutor(), rm) { 
                    @Override
                    protected void handleOK() {
                        rm.done();
                    }
            	}
            );
        }else {
            rm.setStatus(new Status(IStatus.ERROR, PDAPlugin.PLUGIN_ID, IDsfService.INVALID_STATE, "Given context: " + context + ", is already running.", null)); //$NON-NLS-1$ //$NON-NLS-2$
            rm.done();
        }
	}
	
	public void suspend(IExecutionDMContext context, final RequestMonitor rm){
		assert context != null;

		if (canSuspend(context)) {
            fCommandControl.queueCommand(
                new PDASuspendCommand(fCommandControl.getDMContext()),
                new DataRequestMonitor<PDACommandResult>(getExecutor(), rm));
            
        } else {
            rm.setStatus(new Status(IStatus.ERROR, PDAPlugin.PLUGIN_ID, IDsfService.INVALID_STATE, "Given context: " + context + ", is already suspended.", null)); //$NON-NLS-1$ //$NON-NLS-2$
            rm.done();
        }
    }
    
    public boolean canStep(IExecutionDMContext context) {
        return canResume(context);
    }
    
    public void step(IExecutionDMContext context, StepType stepType, final RequestMonitor rm) {
    	assert context != null;
    	
    	if (canResume(context)) {
            fResumePending = true;
            fStepping = true;
            fCommandCache.setTargetAvailable(false);

            fCommandControl.queueCommand(
                new PDAStepCommand(fCommandControl.getDMContext()),
                new DataRequestMonitor<PDACommandResult>(getExecutor(), rm));

    	} else {
            rm.setStatus(new Status(IStatus.ERROR, PDAPlugin.PLUGIN_ID, INVALID_STATE, "Cannot resume context", null)); //$NON-NLS-1$
            rm.done();
            return;
        }
    }

    public boolean canInstructionStep(IExecutionDMContext context) {
        return false;
    }
    
    public void instructionStep(IExecutionDMContext context, StepType stepType, RequestMonitor rm) {
        rm.setStatus(new Status(IStatus.ERROR, PDAPlugin.PLUGIN_ID, NOT_SUPPORTED, "Operation not implemented", null)); //$NON-NLS-1$
        rm.done();
    }

    public void getExecutionContexts(final IContainerDMContext containerDmc, final DataRequestMonitor<IExecutionDMContext[]> rm) {
        rm.setStatus(new Status(IStatus.ERROR, PDAPlugin.PLUGIN_ID, NOT_SUPPORTED, "Operation not implemented", null)); //$NON-NLS-1$
        rm.done();
    }
    
	public void getExecutionData(IExecutionDMContext dmc, DataRequestMonitor<IExecutionDMData> rm){
        rm.setData( new ExecutionData(fStateChangeReason) );
        rm.done();
    }
}
